(function(exports){

    var https     = require('https');
    var url       = require('url');
    var extend    = require('deep-extend');
    var async     = require('async');
    var util      = require('util');
    var attempt   = require('attempt');
    var EventEmitter = require('events').EventEmitter;
    var creds     = require('./lib/credentials')
    var poll      = require('./lib/longPoll');
    var request   = require('superagent');
    require('superagent-retry')(request);
    require('./lib/grace')(request);

    var profiles  = require('./lib/profiles');

    //connection - instruments
    var instruments = require('./lib/stats').instruments;

    var stats = exports.stats = {
        read: function () {
            return {
                requests: {
                    total    : instruments.requests.toJSON(),
                    reads    : instruments.reads.toJSON(),
                    writes   : instruments.writes.toJSON(),
                    bytes    : instruments.bytes_sent.toJSON()
                },
                responses: {
                    successes: instruments.responses.toJSON(),
                    errors   : instruments.errors_total.toJSON(),
                    stalls   : instruments.stalls.toJSON(),
                    resets   : instruments.timeouts.toJSON(),
                    timeouts : instruments.resets.toJSON(),
                    bytes    : instruments.bytes_received.toJSON()
                }
            }
        },

        reset: function () {
            instruments.requests.reset();
            instruments.reads.reset();
            instruments.writes.reset();
            instruments.responses.reset();
            instruments.bytes_sent.reset();
            instruments.bytes_received.reset();
            instruments.errors_total.reset();
            instruments.resets.reset();
            instruments.timeouts.reset();
            instruments.stalls.reset();
        }
    };

    var DEFAULTS  = {
        timeout      : 60*1000,
        maxConcurrent: 10
    };

    var RETRY_POLICY = {
        retries : 2,
        interval: 4*1000,
        factor  : 2,
        random  : 0.33
    };

    var cloudAgent = new https.Agent({ keepAlive: true });
    var DEFAULT_SERVICE = "https://api.bodhi.space";
    var MB = 1024*1000/2;

    function toPath(arg){
        return (typeof arg === Array || arg instanceof Array) ? arg.join('/') : arg;
    }

    function isEmptyArray(arr){
        return (Array.isArray(arr) && arr.length === 0)
    }


    function noop(err){}

    function safeCallback(cb){
        return (cb && typeof cb === 'function') ? cb : noop;
    }

    function handleError(client, req){
        return function(err, cb) {
            var msg = err.message;
            if (err.response) {
                //http | api error
                var res = err.response;
                var json = res.body;
                if (!/^application\/json/i.test(res.headers['content-type'])) {
                    err = new Error(util.format('Network Error %s: %s', err.code, msg));
                    err.issues = 'no server response available';
                    err.code = 'json.error';
                    err.text = res.text;
                } else if (json.length > 1) {
                    err = new Error(util.format('Api Error (%d) %s: %s', res.statusCode, req.uri));
                    err.issues = json;
                } else if (json.length === 1) {
                    json = json[0];
                    err = new Error(util.format('Api Error (%d) %s: %s', res.statusCode, req.uri, json.message));
                    err.code = json.code;
                    err.status = json.parameters;
                } else {
                    err = new Error(util.format('Api Error (%d) %s: %s', res.statusCode, req.uri, msg));
                }
                err.status = res.statusCode;
                err.api = true;
                err.text = res.text;
            }
            err.source = req || {};
            client.emit('failed', err, res);
            return cb(err);
        }
    }


    function handleSuccess(client, req){
        return function(response, cb){

            client.emit('success', response);

            var ctx = {
                statusCode: response.statusCode,
                headers: response.headers,
                request: req
            };

            client.emit('response', response, ctx);

            switch (response.statusCode) {
                case 200:
                    return cb(null, response.body, ctx);
                case 201:
                    return cb(null, response.headers.location || null, ctx);
                case 202:
                    ctx.json = response.body;
                    return cb(null, response.body, ctx);
                case 204:
                    return cb(null, null, ctx);
                default:
                    return cb(null, null, ctx);
            }
        }
    }

    function errorCallback(cb, req, client){
        cb = safeCallback(cb);
        req = req || req;
        return function(err, response) {
            try {
                if (err) {
                    return handleError(client, req)(err, cb)
                } else {
                    return handleSuccess(client, req)(response, cb)
                }
            } catch (err){
                client.emit('failed', err);
                cb(err);
            }
        }
    }


    var _engine;
    var VERSION = exports.version = require('./package.json').version;
    var NAME    = exports.name = require('./package.json').name;
    var DRIVER  = NAME + '/' + VERSION;

    var setEngine = exports.setEngine = function(engine){
        if(!_engine) {
            _engine = engine;
        }
        return exports;
    };

    Object.defineProperty(exports, 'engine', {
        get: function() { return _engine },
        enumerable: true,
        configurable: false
    });

    //@convered
    exports.toString = function(){
        return DRIVER;
    };

    var Client = exports.Client = function(options){

        var client      = this;
        var profile     = profiles.standard;
        var _credential = null;
        var _ctx;

        options = options || {};

        //if uri => url
        if(options.uri){
            options.url = options.uri;
            delete options.uri;
        }

        //if !url => default
        if(!options.url){
            options.url = DEFAULT_SERVICE;
        }

        //if ns => safe namespace
        if(options.namespace && options.namespace.indexOf('/') > 0){
            options.namespace = (options.namespace.substring(0, options.namespace.indexOf('/')));
        }

        //if url and ns => url/ns/
        if(options.namespace && options.url){
            options.url = url.resolve(options.url, options.namespace + '/');
            delete options.namespace;
        }

        //if there is a profile assigned
        if(options.profile && profiles[options.profile]){
            profile = profiles[options.profile];
        }

        //consume the credentials
        if(options.credentials){
            _credential = options.credentials;
            delete options.credentials;
        }

        if(options.context){
            _ctx = options.context;
        }

        var requestStyle     = (options.direct) ? 'send' : 'enqueue';

        function backedOff(err){
            return (err && (err.status === 429));
        }

        function driverGaveUp(err){
            return (err && (
            err.code === 'ETIMEDOUT' || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNABORTED")
            );
        }

        function serverGaveUp(err){
            return (err && (err.code === 'ECONNRESET'));
        }

        function healthCheck(){
            client.send('/', {method: "get"}, function(){});
        }

        var available = true;
        var lastErr = undefined;

        function resumeProcessing(err, result){
            if(err){
                available = false;
                lastErr = err;
                requestQueue.resume();
            } else {
                requestQueue.resume();
            }
        }

        var buffer = [];

        //Reliable Request Queue
        //Try the send ...
        var requestQueue = async.queue(function work(requestCtx, responseHandler) {
            try {
                instruments.requests.inc();
                var r = client.createRequest(requestCtx)
                    .end(function (err, json, res) {
                        try {
                            if(!available){
                                return responseHandler(lastErr || new Error('connection unavailable'));
                            } else {
                                if (backedOff(err)) {
                                    instruments.stalls.inc();
                                } else if (serverGaveUp(err)) {
                                    instruments.resets.inc();
                                } else if (driverGaveUp(err)) {
                                    instruments.timeouts.inc();
                                }
                                return responseHandler(err, json, res);
                            }
                        } catch (err){
                            client.emit('failed', err, requestCtx);
                        }
                    });
            } catch (err){
                client.emit('failed', err, requestCtx);
            }
        }, profile.concurrent || DEFAULTS.maxConcurrent);


        requestQueue.drain = function(){
            available = true;
            client.emit('drained')
        };

        requestQueue.empty = function(){
            client.emit('emptied')
        };

        requestQueue.saturated = function(){
            client.emit('saturated')
        };

        client.idle = function(){
            return requestQueue.idle();
        };

        client.depth = function(){
            return client.pending() + client.processing();
        };

        client.pending = function(){
            return requestQueue.length()
        };

        client.processing = function(){
            return requestQueue.running();
        };

        client.paused = function(){
            return requestQueue.paused
        };

        client.resume = function(){
            if(requestQueue.paused){
                requestQueue.resume();
                client.emit('resumed');
            }
        };

        //
        client.on('response', function(){
            client.resume();
        });

        client.timeout = profile.timeout || DEFAULTS.timeout;

        //@covered
        client.setContext = function(ctx){
            _ctx = ctx;
            return client;
        };

        //@covered
        client.createUserAgent = function(){
            var cred = _credential || {};
            return util.format('%s %s %s %s %s',
                cred.userAgent || 'bodhi-agent',  //bearer
                'nodejs/' + process.version,      //runtime
                DRIVER,                                  //driver
                _engine || '',                           //engine
                _ctx    || ''                            //local-context
            ).trimRight();
        };


        //@convered
        Object.defineProperty(client, 'origin', {
            get: function() {
                var origin = undefined;
                if(options.url){
                    origin = url.parse(options.url);
                    origin = util.format('%s//%s', origin.protocol, origin.host);
                }
                return origin;
            },
            enumerable: true,
            configurable: false
        });

        //@convered
        Object.defineProperty(client, 'namespace', {
            get: function() {
                var _path = undefined;
                if(options.url){
                    _path = url.parse(options.url);
                    _path = _path.pathname.split('/')[1];
                    _path = (!_path.length) ? undefined : _path;
                }
                return _path;
            },
            enumerable: true,
            configurable: false
        });

        //resolve the endpoint
        //@convered
        client.resolve = function path(path){
            if(path == null) path = '';
            if('string' !== typeof path){
                switch(typeof path){
                    case 'number':
                    case 'boolean':
                        path = path.toString();
                        break;
                    case 'object':
                        path = Array.isArray(path) ? path.join('/') : path.toString();
                        break;
                    default:
                        path = '';
                        break;
                }
            }
            return url.resolve(options.url, toPath(path || ''));
        };

        //@convered
        Object.defineProperty(client, 'engine', {
            get: function() { return _engine },
            set: setEngine,
            enumerable: true,
            configurable: false
        });

        //@convered
        Object.defineProperty(client, 'context', {
            get: function() {
                return _ctx;
            },
            enumerable: false,
            configurable: false
        });

        //@convered
        Object.defineProperty(client, 'userAgent', {
            get: function() { return client.createUserAgent(); },
            enumerable: true,
            configurable: false
        });

        //@convered
        client.use = client.setNamespace = function(ctx){

            if(ctx && ctx.indexOf('/') > 0){
                ctx = (ctx.substring(0, ctx.indexOf('/')));
            }

            if(ctx && options.url){
                options.url = url.resolve(options.url,  '/' + ctx + '/');
            }

            return client;
        };


        client.setCredential = client.as = function(credential){
            _credential = credential;
            return client;
        };

        client.asUser = function(username, password){
            _credential = new BasicCredential(username, password);
            return client;
        };

        client.asBearer = function(token){
            _credential = new BearerToken(token);
            return client;
        };

        client.asCookie = function(cookie){
            _credential = new CookieAuth(cookie);
            return client;
        };


        //each key represents a url, each value represents a new entry for the values
        /*
         * {
         *   'resources/MyType': {name: "name", uri: "http://localhost/a/b", system_v: true }
         *   'resources/AType' : [{}, {}, {}]
         *   'resources/BType' : [{}, {}, {}]
         * }
         */
        client.postAll = function postAll(resources, completed){
            var bag = {};
            async.forEachOfSeries(resources, function(value, key, posted){
                client.post(key, value, function(err, json, response){
                    bag[key] = (err) ? error: json;
                    posted();
                })
            }, function(err){
                completed(null, bag)
            })
        };

        //post(resource)           ==> sendNoData
        //post(resource, json)     ==> sendAndIgnore
        //post(resource, cb)       ==> invokeAnOperation without a payload
        //post(resource, json, cb) ==> sendAndWait
        //@covered
        client.post = function post(resource, json, cb){
            var options = {method: 'POST', body: json};

            if(arguments.length === 4) {
                if(typeof arguments[2] === 'object'){
                    options = extend(options, arguments[2]);
                } else {
                    options.timeout = arguments[2];
                }
                cb = arguments[3]
            }

            if(arguments.length === 2) {
                if(typeof arguments[1] === 'function'){
                    delete options.json;
                    delete options.body;
                    cb   = arguments[1];
                } else {
                    cb   = noop;
                }
            }

            //use the profile limit
            if(Array.isArray(json)){
                var results   = [];
                var responses = [];

                //force the batch size up to 100
                var BATCH = (profile.batch_size > 100) ? profile.batch_size : 100;

                async.eachSeries(chunkByObjects(json, profile.batch_size), function(chunk, callback){
                    options.body = chunk;
                    client[requestStyle](resource, options, function(err, json, res){
                        try {
                            results = results.concat(json);
                            responses = responses.concat(res);
                            callback(err);
                        } catch (err){
                            callback(err);
                        }
                    });
                }, function(err){
                    try {
                        cb && cb(err, results, responses)
                    } catch (err){
                        client.emit('failed', err)
                    }
                });
            } else {
                client[requestStyle](resource, options , cb);
            }
        };

        //chunckingByObjects
        function chunkByObjects(json, limit){
            var chunks = [];
            var size = json.length;
            if (size > limit) {
                var pieces = Math.floor(size / limit) + 1;
                var i, j;
                for (i = 0; i < size; i += limit) {
                    chunks.push(json.slice(i, i + limit));
                }
            } else {
                chunks.push(json);
            }
            return chunks;
        }

        //demand JSON
        //@covered
        client.put = function put(resource, json, cb){

            if(arguments.length === 2){
                return safeCallback(json)(new Error('Illegal Arguments: No document specified'))
            } else if (arguments.length === 1 ) {
                return safeCallback(resource)(new Error('Illegal Arguments: No resource or document specified'))
            }

            client[requestStyle](resource, {method: 'PUT', body: json} , cb);
        };

        //demand JSON
        //@covered
        client.patch = function patch(resource, json, cb){

            if(arguments.length === 2){
                return safeCallback(json)(new Error('Illegal Arguments: No patch document specified'))
            } else if (arguments.length === 1 ) {
                return safeCallback(resource)(new Error('Illegal Arguments: No resource or patch document specified'))
            }

            client[requestStyle](resource, {method: 'PATCH', body: json} , cb);
        };


        //@covered
        client.delete = function del(resource , cb){
            client[requestStyle](resource, {method: 'DELETE'} , cb);
        };

        //@covered
        client.me = function get(cb){
            client[requestStyle]('/me', {method: 'GET'}, cb);
        };

        //@covered
        client.get = function get(resource , cb){
            client[requestStyle](resource, {method: 'GET'}, cb);
        };

        function getPages(res, options, cb){

            var results = [];

            cb            = cb            || noop();
            options       = options       || {};
            options.limit = options.limit || 10;

            getPage(new PageIterator(res), 0);

            function getPage(res, page){
                client[requestStyle](res.toUrl(), {method: 'GET'}, function(err, json, response){
                    if(err){
                        cb(err);
                    } else if(Array.isArray(json)){
                        page = page + 1;
                        results = results.concat(json);
                        if(json.length === 100 && page < options.limit){
                            getPage(res.next(), page);
                        } else {
                            response.pages = page;
                            cb(null, results, response)
                        }
                    } else {
                        response.pages = page;
                        cb(null, [json], response)
                    }
                })
            }
        }

        client.getPages = function get(resource, options, cb){
            getPages(resource, options, cb);
        };

        //read until the end ....
        client.getAll = function get(resource, cb){
            getPages(resource, {
                limit: Number.POSITIVE_INFINITY
            }, cb);
        };

        //get One (Or None) as an Object
        client.fetch = function fetch(resource , cb){
            cb = safeCallback(cb);
            client[requestStyle](resource, {method: 'GET'}, function(err, json, ctx){
                if(!err && ctx.statusCode === 200){
                    if(Array.isArray(json)){
                        if(json.length === 1){
                            json = json[0];
                        } else if(json.length === 0) {
                            json = null;
                        } else {
                            err = new Error('More than one resource found');
                        }
                    }
                }
                cb && cb(err, json, ctx);
            });
        };

        function asResource(uri, obj){
            var parts = url.parse(uri);
            var path = parts.pathname.split('/');
            return [path[0], path[1], obj.sys_id].join('/');
        }

        function asResourcePath(uri){
            var parts = url.parse(uri);
            var path = parts.pathname.split('/');
            return [path[0], path[1]].join('/');
        }

        //look and object up and change it
        function fetchAnd(resource, action, cb){
            async.waterfall([
                async.apply(client.fetch, resource),
                async.apply(action, resource)
            ], function(err, result){
                if(Array.isArray(result)){
                    cb(err, result[0], result[1])
                } else {
                    cb(err, result)
                }
            });
        }

        //@covered
        client.serverUpsert = function upsert(resource, data, done){
            var res = util.format('%s?upsert=true', toPath(resource || ''));
            client.put(res, data, function(err, json, ctx){
                if(!err) {
                    ctx.action = (ctx.statusCode === 201) ? 'created' : 'modified';
                }
                return done(err, json, ctx);
            })
        };


        //Fetch One & Update it exists or Insert if not, fail if not available
        client.upsert = function upsert(resource, representation, done){
            var res;

            if(!resource){
                return done(new Error('invalid url: expected a value but received '));
            }

            res = url.parse(resource).pathname;

            /*
             * fields=sys_id
             */
            fetchAnd(resource, function(resource, object, ctx, callback){
                if(!object) {
                    client.post(res, representation, function(err, json, ctx){
                        callback(err, [json, ctx]);
                    })
                } else {
                    var uri = [res, object.sys_id].join('/');
                    representation.sys_id = object.sys_id;
                    client.put(uri, representation, function(err, json, res){
                        callback(err, [uri, res]);
                    })
                }
            },done);
        };

        //Fetch One & Replace
        client.fetchAndUpdate = function fetchAndUpdate(resource, update, done){
            fetchAnd(resource, function(resource, object, ctx, callback){
                if(!object){
                    callback(new Error('No matching resource available'), null, null);
                } else {
                    object = update(object);
                    var res = asResource(resource, object);
                    client.put(res, object, function(err, json, ctx){
                        callback(err, ctx);
                    })
                }
            },done);
        };


        //Fetch One & Replace
        client.fetchAndExtend = function fetchAndExtend(resource, extension, done){
            fetchAnd(resource, function(resource, document, ctx, callback){
                if(!document){
                    callback(new Error('No matching resource available'), null, null);
                } else {
                    document = extend(document, extension);
                    var res = asResource(resource, document);
                    client.put(res, document, function (err, json, ctx) {
                        callback(err, ctx);
                    })
                }
            },done);
        };

        client.fetchAndPatch = function fetchAndPatch(resource, patch, done){
            fetchAnd(resource, function(resource, object, ctx, callback){
                if(!object){
                    callback(new Error('No matching resource available'), null, null);
                } else {
                    var res = asResource(resource, object);
                    client.patch(res, patch, function (err, json, ctx) {
                        callback(err, ctx);
                    })
                }
            },done);
        };

        client.fetchAndRemove = function fetchAndRemove(resource , done){
            fetchAnd(resource, function _remove(resource, object, ctx, callback){
                if(!object){
                    callback(new Error('No matching resource available'), null, null);
                } else {
                    var res = asResource(resource, object);
                    client.delete(res, function(err, json, ctx) {
                        callback(err, ctx);
                    })
                }
            },done);
        };

        //- update a complete set of objects
        client.findAndUpdate = function findUpdate(resource, update, done){
            var results = {updated: 0, failed: 0};
            var res = asResourcePath(resource);
            //@todo - change back to getall
            client.getAll(resource, function (err, json, response) {
                if(err){
                    done(err);
                } else {
                    if (!json || isEmptyArray(json)) {
                        return done(results)
                    } else {
                        async.eachSeries(json, function (obj, updated) {
                            id = obj.sys_id;
                            obj = update(obj);
                            if(typeof obj !== 'object'){
                                return done(new Error('Object destroyed'));
                            }
                            obj.sys_id = id;
                            client.put([res, obj.sys_id], obj, function (err) {
                                if (err) {
                                    results.failed++;
                                    updated()
                                } else {
                                    results.updated++;
                                    updated()
                                }
                            })
                        }, function (err) {
                            done(results);
                        })
                    }
                }
            })
        };

        //delete a set of objects
        client.findAndRemove = function del(resource , done){
            var results = {removed: 0, failed: 0};
            var res = asResourcePath(resource);
            //@todo - change back to getall
            client.getAll(resource, function (err, json) {
                if(err){
                    done(err);
                } else {
                    if (!json || isEmptyArray(json)) {
                        done(results)
                    } else {
                        async.eachSeries(json, function (obj, deleted) {
                            client.delete([res, obj.sys_id].join('/'), function (err, json, response) {
                                if (err) {
                                    results.failed++;
                                    deleted()
                                } else {
                                    results.removed++;
                                    deleted()
                                }
                            })
                        },function (err) {
                            done(results);
                        })
                    }
                }
            })
        };

        //gather data
        function _gather(action, queries, options, gathered) {
            var bag = {};
            options = options || {};
            async.forEachOf(queries, function (query, key, callback) {
                client[action](query, function(err, json, ctx){
                    if(err){
                        return (options.err) ? callback(err) : callback(null, err);
                    } else {
                        bag[key] = json;
                        callback(err, json);
                    }
                });
            }, function (err) {
                gathered(err, bag);
            });
        };

        //gatherUp
        client.gather = function gather(queries, options, gathered){
            if(arguments.length <= 2){
                gathered = options;
                options  = {};
            }
            _gather('get', queries, options, gathered)
        };

        //gatherUpAll
        client.gatherAll = function gather(queries, options, gathered){
            if(arguments.length <= 2){
                gathered = options;
                options  = {};
            }
            _gather('getAll', queries, options, gathered);
        };

        client.enqueue = function async(resource, options, cb){
            options = options || {};
            options.uri = client.resolve(resource || '');
            requestQueue.push(options,
                errorCallback(cb, {uri: options.uri, method: options.method, entity: options.body }, client));
        };

        client.send = function request(resource, options, cb){
            options = options || {};
            options.uri = client.resolve(resource || '');
            instruments.requests.inc();
            client.createRequest(options).end(
                errorCallback(cb, {uri: options.uri, method: options.method, entity: options.body}, client));
        };


        //execute a set of batch commands
        client.batch = function(commands, executed) {
            async.map(commands,
                function itr(cmd, callback) {
                    client.send(cmd.url, cmd, function (err, doc, res) {
                        if (err) {
                            return callback(err);
                        } else {
                            //forward the gets and posts
                            if(/post|get/i.test(cmd.method)){
                                return (err) ? callback(err) : callback(null, {document: doc, response: res});
                            } else {
                                return (err) ? callback(err) : callback(null, {response: res});
                            }
                        }
                    })
                },
                executed
            )
        };

        client.file = {};


        function normalizeFilePath(uploadPath){
            uploadPath = (!uploadPath || '' === uploadPath || /^s+$/.test(uploadPath)) ? '' : uploadPath;

            if(uploadPath.indexOf('/') === 0){
                uploadPath = uploadPath.substring(1);
            }
            return util.format('controllers/vertx/upload/%s', uploadPath);
        }

        //@covered
        client.file.upload = function(uploadPath, filePath, options, uploaded){

            var uploadedAs = 'data';

            if(arguments.length < 4){
                uploaded = options || noop;
                options  = {}
            }

            if (!options.directPath) {
                uploadPath = normalizeFilePath(uploadPath);
            }

            requestUpload({
                uri : client.resolve(uploadPath),
                method: options.method ? options.method: 'PUT'
            }, filePath, require('path').parse(filePath).base, uploaded)
        };

        client.file.uploadFile = client.file.upload;

        //@covered
        client.file.uploadContent = function(uploadPath, content, options, uploaded){

            if(arguments.length < 4){
                uploaded = options || noop;
                options  = {}
            }

            if (!options.directPath) {
                uploadPath = normalizeFilePath(uploadPath);
            }

            if(!content){
                content = new Buffer('');
            }

            if(typeof content === "string"){
                var encoding = options.encoding || 'utf8';
                content = new Buffer(content, encoding);
            }

            requestUpload({
                uri   : client.resolve(uploadPath),
                method: 'PUT'
            }, content, 'buffer', uploaded)

        };

        function requestUpload(requestParameters, content, param, uploaded) {
            function upload(req, content) {
                return function _upload(_done) {
                    client.createRequest(requestParameters)
                        .attach(options.name || 'upload', content, 'buffer')
                        .end(errorCallback(function (err, doc, res) {
                            _done(err, {doc: doc || null, res: res || null})
                        }, req, client));
                }
            }

            async.retry({
                times: 4,
                interval: function (retryCount) {
                    return 500 * Math.pow(1.61, retryCount);
                }
            }, upload(requestParameters, content), function (err, result) {
                uploaded(err, null, result.res)
            });
        }


        //@covered
        client.file.download = function(downloadPath, options, downloaded){

            if(arguments.length < 3){
                downloaded = options || noop;
                options  = {name: 'file'}
            }

            if (!options.directPath) {
                downloadPath = normalizeFilePath(downloadPath);
            }

            var requestParameters = {
                uri : client.resolve(downloadPath),
                method: 'GET'
            };

            async.retry({
                times: 5,
                interval: function (retryCount) {
                    return 500 * Math.pow(1.61, retryCount);
                }
            }, function download(done) {
                    client.createRequest(requestParameters)
                        .buffer()
                        .end(function(err, response){
                            var content;
                            try {
                                if (err) {
                                    done(err);
                                } else {
                                    client.emit('success', response);
                                    var ctx = {
                                        statusCode: response.statusCode,
                                        headers   : response.headers,
                                        request   : requestParameters
                                    };
                                    client.emit('response', response, ctx);

                                    content = (response.text) ? new Buffer(response.text) : new Buffer('');

                                    var results = {
                                        content: content,
                                        ctx: ctx
                                    };
                                    done(null, results);
                                }
                            } catch (err){
                                done(err);
                            }
                        });
                }, function (err, result) {
                    if(err){
                        return handleError(client, requestParameters)(err, downloaded)
                    } else{
                        return downloaded(null, result.content, result.ctx)
                    }
                    
            });
        };

        //@Fisher Pull Request
        client.file.createDownloadStream = function(downloadPath, timeout){

            downloadPath = normalizeFilePath(downloadPath);

            var requestParameters = {
                uri : client.resolve(downloadPath),
                method: 'GET',
                timeout: timeout
            };

            var _request = client.createRequest(requestParameters);

            function _pipe(writable, options) {
                _request.pipe(writable, options || {name: 'file'});
            }

            return {
                onError: function (errorCB) {
                    _request.on('error', function (err) {
                        try {
                            return handleError(client, requestParameters)(err, errorCB)
                        } catch (err) {
                            errorCB(err);
                        }
                    });
                    return _request;
                },
                pipe: _pipe
            }
        };

        function binaryParser(res, callback) {
            res.setEncoding('binary');
            res.data = '';
            res.on('data', function (chunk) {
                res.data += chunk;
            });
            res.on('end', function () {
                callback(null, new Buffer(res.data, 'binary'));
            });
        }

        //@covered
        client.file.downloadBinary = function(downloadPath, options, downloaded){

            if(arguments.length < 3){
                downloaded = options || noop;
                options  = {name: 'file'}

            }

            var requestParameters = {
                uri : client.resolve(downloadPath),
                method: 'GET'
            };

            async.retry({
                times: 5,
                interval: function (retryCount) {
                    return 500 * Math.pow(1.61, retryCount);
                }
            }, function download(done) {
                    client.createRequest(requestParameters)
                        .parse(binaryParser)
                        .buffer()
                        .end(function(err, response){
                            var content;
                            try {
                                if (err) {
                                    done(err);
                                } else {
                                    client.emit('success', response);
                                    var ctx = {
                                        statusCode: response.statusCode,
                                        headers   : response.headers,
                                        request   : requestParameters
                                    };
                                    client.emit('response', response, ctx);

                                    content = (response.body) ? response.body : new Buffer('','binary');

                                    var results = {
                                        content: content,
                                        ctx: ctx
                                    };
                                    done(null, results);
                                }
                            } catch (err){
                                done(err);
                            }
                        });
                }, function (err, result) {
                    if(err){
                        return handleError(client, requestParameters)(err, downloaded)
                    } else{
                        return downloaded(null, result.content, result.ctx)
                    }
                    
            });
        };


        function getBytes(val){
            try{
                return parseInt(val, 10) || 0;
            } catch (err){
                return 0;
            }
        }

        //error instruments
        client.on('failed', function errorMonitor(err, res){
            try {
                instruments.errors_total.inc();
                instruments.bytes_sent.inc(getBytes(res.req._headers['content-length']));
                if (res.length) {
                    instruments.bytes_received.inc(getBytes(res.length));
                } else {
                    instruments.bytes_received.inc(getBytes(res.headers['content-length']));
                }
            } catch (error){}
        });

        client.on('success', function errorMonitor(res){
            try {
                instruments.responses.inc();
                instruments.bytes_received.inc(getBytes(res.headers['content-length']));
                instruments.bytes_sent.inc(getBytes(res.req._headers['content-length']));
            } catch (err){}
        });

        client.createRequest = function(req){
            var q;

            req = req || {};

            if(req.uri){
                req.url = req.uri;
            }

            if(!req.url){
                throw new Error('Invalid Request: Expected a uri');
            }

            if(!req.method){
                throw new Error('Invalid Request: Expected a method /get|post|put|patch|delete/');
            }

            q = request(req.method, req.uri);
            q.agent(cloudAgent);

            //this should be an event mechanism
            if(/get/gi.test(req.method)){
                q.retry(5);
                instruments.reads.inc();
            } else {
                q.backoff(2, 2000);
                instruments.writes.inc();
            }

            //authorize the connection
            if(_credential && _credential.auth){
                q = _credential.auth(q);
            }

            q.set('User-Agent', client.createUserAgent());

            if(req.body) {
                q.type('json');
                q.send(req.body);
            }

            q.timeout(computeTimeout(req));

            return q;
        };

        client.createMonitor = function(){
            var monitor = poll(client.get)();
            return monitor;
        };

        client.monitor = function(url, callback){
            var monitor = client.createMonitor();
            monitor.run(url, callback);
            return monitor;
        };

        //extension point
        client.bulk = {};

        client.bulk.monitor = function(id, found){
            function checkStatus(_url, done){
                client.get(_url, function(err, doc, res){
                    if(err){
                        done(null, err, doc, res)
                    } else {
                        if(res.statusCode === 204){
                            done(new Error('status unavailable'), null, doc, res)
                        } else {
                            done(null, err, doc, res)
                        }
                    }
                })
            }
            var monitor = poll(checkStatus)();
            monitor.run(id, function(err, exit, doc, res){
                if(err){
                    found(err, null, res);
                } else {
                    found(exit, doc, res);
                }
            });
            return monitor;
        };

        client.bulk.post   = function(items, options, callback){

            options  = options || {};
            callback = callback || noop;

            if(!options.op){
                return callback(new Error('Missing Bulk Operation'))
            }

            if(!/insert|update|upsert|invite|diff/i.test(options.op)){
                return callback(new Error('Invalid Bulk Operation'))
            }

            if(/diff/i.test(options.op) && !options.range){
                return callback(new Error('Missing Range for Diff Operation'))
            }

            if(!options.target){
                return callback(new Error('Missing Bulk Resource Target'))
            }

            if(!items){
                return callback(new Error('Missing Bulk Items'))
            }

            if(typeof items === 'object' && !Array.isArray(items)){
                items = [items];
            }

            return client.post('bulk', {
                config : options,
                payload: items
            }, function(err, doc, res){
                if(err){
                    callback(err)
                } else {
                    callback(err, 'bulk/' + res.headers.bulk_id, res)
                }
            })
        };

        client.bulk.insert = function(res, items, callback){
            return client.bulk.post(items, {op: "insert", target: res, report: true}, callback)
        };

        client.bulk.update = function(res, items, callback){
            return client.bulk.post(items, {op: "update", target: res, report: true}, callback)
        };

        client.bulk.upsert = function(res, items, callback){
            return client.bulk.post(items, {op: "upsert", target: res, report: true}, callback)
        };

        client.bulk.diff = function(res, items, range, callback){
            if(!callback){
                callback = range;
                return callback(new Error('Missing Range for Diff Operation')) 
            }
            return client.bulk.post(items, {op: "diff", target: res, range: range, report: true}, callback)
        };

        //special ...
        client.bulk.invite = function(users, callback){
            return client.bulk.post(users, {op: "invite", target: 'User', report: true}, callback)
        };

        //- Representations
        client.toString  = function(){
            return util.format("%s@%s", _credential ? _credential.toString() : 'anonymous', client.resolve());
        };

        //compute the timeout
        function computeTimeout(req){

            var timeout;

            //a declared timeout honor it
            if(req.timeout){
                timeout = req.timeout;
            } else if(client.timeout){
                //if this is an array ...
                if(req.body && Array.isArray(req.body)){
                    timeout = client.timeout * profile.batch_factor || 1;
                } else {
                    timeout = client.timeout
                }
            } else {
                timeout = DEFAULTS.timeout;
            }

            return timeout;
        }
    };

    //Make the client an event emitter
    util.inherits(Client, EventEmitter);


    var PageIterator = function(res){

        function getPageParameter(page){
            return util.format("limit:%d,page:%d", 100, page)
        }

        var parsed = url.parse(res, true);

        if(!parsed.query){
            parsed.query = {}
        }

        var page = 1;
        parsed.query.paging = getPageParameter(page);

        //delete parsed.path;
        delete parsed.search;

        //get the first
        this.toUrl = function(){
            return url.format(parsed)
        };

        //get the next
        this.next = function(){
            page = page + 1;
            parsed.query.paging = getPageParameter(page);
            return this;
        };
    };


    //@covered
    exports.Patch           = require('./lib/rest-patch').Patch;
    exports.ResourceFilter  = require('./lib/filter').ResourceFilter;
    var BasicCredential     = exports.BasicCredential = creds.BasicCredential;
    var BearerToken         = exports.BearerToken     = creds.BearerToken;
    var CookieAuth          = exports.CookieAuth      = creds.CookieAuth;

    exports.createUserClient  = function(user, password, namespace){
        if(!user || !password){
            throw new Error('Unspecified credentials: Missing either username of password');
        } else {
            var ctx = {
                credentials: new BasicCredential(user, password)
            };
            if(namespace) ctx.namespace = namespace;
            return new Client(ctx)
        }
    };

    exports.createAgentClient = function(token, namespace){
        if(!token){
            throw new Error('Unspecified credentials: Missing bearer token');
        } else {
            var ctx = {
                credentials: new BearerToken(token)
            };
            if(namespace) ctx.namespace = namespace;
            return new Client(ctx)
        }
    };

    //@deprecating? - should be a singleton?
    exports.createPublicClient = exports.createClient = function(options){

        options = options || {};

        //if string ... assume URI
        if('string' === typeof options) {
            options = {uri: options};
        }

        return new Client(options)
    };

    //@deprecating ...
    exports.createSystemClient = function(options){

        options = options || {};

        //if string ... assume URI
        if('string' === typeof options) {
            options = {uri: options};
        }

        options = extend(options, {namespace: 'system'});

        return new Client(options);
    };

})(module.exports);