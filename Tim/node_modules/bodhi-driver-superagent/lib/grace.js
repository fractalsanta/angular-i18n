/**
 * Add to the request prototype.
 */
module.exports = function (superagent) {
    'use strict';

    var Request = superagent.Request;
    Request.prototype.backoff = backoff;

    /**
     * Sets the amount of times to retry the request
     * @param  {Number} count
     */

    function backoff (retries, wait) {

        var self    = this,
            oldEnd  = this.end;

        retries = retries || 1;
        wait    = wait    || 5*1000;

        this.end = function (fn) {
            var timeout = this._timeout;

            function attemptRetry () {
                return oldEnd.call(self, function (err, res) {
                    if (!retries || !shouldRetry(err, res)) {
                        try {
                            return fn && fn(err, res);
                        } catch (err){}
                    }
                    var paused = res.headers.retry || wait;
                    reset(self, timeout);
                    retries--;
                    setTimeout(function(){
                        return attemptRetry();
                    }, paused);
                });
            }

            return attemptRetry();
        };

        return this;
    }


    /**
     * HACK: Resets the internal state of a request.
     */

    function reset (request, timeout) {
        var headers = request.req._headers;
        var path = request.req.path;

        request.req.abort();
        request.called = false;
        request.timeout(timeout);
        delete request.req;
        delete request._timer;

        for (var k in headers) {
            request.set(k, headers[k]);
        }

        if (!request.qs) {
            request.req.path = path;
        }
    }


    /**
     * Determine whether we should retry based upon common error conditions
     * @param  {Error}    err
     * @param  {Response} res
     * @return {Boolean}
     */

    function shouldRetry (err, res) {
        return res && res.status === 429;
    }

    return superagent;
};

